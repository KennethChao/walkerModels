function result = oneStepSimulationSLIPP(xVec, parms)
% ToDo

%% For reusing the liftoff event function from SLIP model
%%
phi0 = xVec(1);
phid0 = xVec(2);
delta0 = parms.delta0;

%%
beta = parms.beta;
rc = parms.rc;
mf = parms.mf;

delta = delta0;
mode = parms.mode;
%% Solver setup
    % ode45 solver option
    optionsStance = odeset('Event', @liftOffEventFcn);%, 'RelTol',1.e-6
    dymStance = @(t, x) dymModelStanceSLIPPendulum(t, x, parms); %dymModelStanceDimensionless
    optionsFlight = odeset('Event', @(t, x)touchDownSLIPPendulumEventFcn(t, x, parms)); %,'RelTol',1.e-6
    dymFlight = @(t, a) dymModelFlightSLIPPendulum(t, a, parms);
    
if strcmp(mode, 'fixedPointOpt')
    iterNumb = 1;
elseif strcmp(mode, 'simulationCheck')    
    iterNumb = 1;
elseif strcmp(mode, 'perturbedSimulation')
    perturbation = 5e-3;
    iterNumb = 4;
end

tspan = 0:0.01:20;

for i = 1:iterNumb
    %% Update initial conditions
    normVel = 1;
    
    if i > 1
        delta = deltaNew;
        phi0 =  x2(end,3);
        phid0 =  x2(end,4);
    end
    if strcmp(mode, 'perturbedSimulation') && i == iterNumb
        delta = perturbedDeltaPlus;
    elseif strcmp(mode, 'perturbedSimulation') && i == iterNumb - 1
        delta = perturbedDeltaMinus;
    elseif strcmp(mode, 'perturbedSimulation') && i == iterNumb - 2        
        phi0 = perturbedPhiPlus;        
    elseif strcmp(mode, 'perturbedSimulation') && i == iterNumb - 3
        newDelta0 = delta0;%deltaNew;
        perturbedDeltaPlus = newDelta0 + perturbation;
        perturbedDeltaMinus = newDelta0 - perturbation;
        newPhi0 = phi0;%deltaNew;
        perturbedPhiPlus = newPhi0 + perturbation;
        perturbedPhiMinus = newPhi0 - perturbation;        
        %
        phi0 = perturbedPhiMinus;
    end
    
    %%  Simulation in stance phase
    
    % Prep initial conditions
    xb0 = [1, -normVel * cos(beta-delta), beta, normVel * sin(beta-delta), phi0, phid0];

    % Solve ode
    [t, x, te, xe, ~] = ode45(dymStance, tspan, xb0, optionsStance); % Runge-Kutta 4th/5th order ODE solver
    
    %%  Simulation in flight phase
    % Convert states to Cartesian space
    % position and velocity of mf
    if  isempty(te)
            xe = x(end,:);
    end
    xe(1),xe(3),xe(5),xe(2),xe(4),xe(6)
    
    
    mfMotion = frameMassCartesianMotionStance(xe(1),xe(3),xe(5),xe(2),xe(4),xe(6),rc);
    mbMotion = bodyMassCartesianMotionStance(xe(1),xe(3),xe(5),xe(2),xe(4),xe(6),rc);

    zfLo = mfMotion(2);
    zfdLo = mfMotion(4);
    xfLo = mfMotion(1); 
    xfdLo = mfMotion(3);
    
    % position and velocity of m
    zbL0 = mbMotion(2);
    zbd0 = mbMotion(4);
    xb0 = mbMotion(1); 
    xbd0 = mbMotion(3);
    
    % position and velocity of COM
    comMotion = motionPointMass2COM(xfLo,zfLo,xb0,zb0,xfdLo,zfdL,xbd0,zbd0,rc,mf);

    xc0 = comMotion(1);
    xcd0 = comMotion(3);
    zc0 = comMotion(2);
    zcd0 = comMotion(4);
    
    x20 = [zc0,zcd0,xe(5),xe(6)];
    
    if zbd0<0 
    x2 = ones(1,4)*1e1;
    t2 = 20;
    else
% Solve ode
    [t2, x2, te2, xe2, ~] = ode45(dymFlight, tspan, x20, optionsFlight); % Runge-Kutta 4th/5th order ODE solver
    end

    
    %%  
    zc = x2(end,1);
    dzc = x2(end,2);
    
    dxc = xcd0;
    xc = xc0 + t2(end)*xcd0;
    
    phi = x2(end,3);
    dphi = x2(end,4);
    
    pointMassMotion = motionCOM2PointMass(xc,zc,phi,dxc,dzc,dphi,rc,mf);

    xdfendFlight = pointMassMotion(5);
    zdfendFlight = pointMassMotion(6);
    %%
    
    % Get states of the next step
    velVec = [xdfendFlight, -zdfendFlight];
    deltaNew = atan2(velVec(2), velVec(1));
    
    if strcmp(mode, 'perturbedSimulation') && i == iterNumb
        deltaNewPlus = [deltaNew; x2(end,3)];
    elseif strcmp(mode, 'perturbedSimulation') && i == iterNumb - 1
        deltaNewMinus = [deltaNew; x2(end,3)];
    elseif strcmp(mode, 'perturbedSimulation') && i == iterNumb - 2
        phiNewPlus = [deltaNew; x2(end,3)];
    elseif strcmp(mode, 'perturbedSimulation') && i == iterNumb - 3
        phiNewMinus = [deltaNew; x2(end,3)];
    end
    
end
% 
if strcmp(mode, 'fixedPointOpt')
    % Return cost
    diffDelta = deltaNew - delta;
    diffVel = 1 - norm(velVec);
    diffPhi = norm([phi0;phid0]-[x2(end,3);x2(end,4)]);
    result = diffDelta^2 + diffVel^2 + diffPhi^2;
elseif strcmp(mode, 'perturbedSimulation')
    % Return second eigen value
    result = [(deltaNewPlus - deltaNewMinus) / 2 / perturbation,...
              (phiNewPlus - phiNewMinus) / 2 / perturbation;
             ];
elseif strcmp(mode, 'simulationCheck')
    % Return second eigen value
    result.x = x;
    result.t = t;
    result.te = te;
    result.xe = xe;
    result.x2 = x2;
    result.xe2 = xe2;
    result.t2 = t2;
    result.te2 = te2;
end

end
clc;
clear;
close all;
addpath('./SLIPP')
addpath('./SLIP')
warning off;

optionsFminunc = optimset('Display', 'off', 'FinDiffType', 'central', 'MaxIter', 1e4);

% delta0 = 0.1;
% phi0 = pi/2+0.2;
% phid0 = -0.1;

sampledNumber1 = 30;
sampledNumber2 = 20;

x = linspace(1,20,sampledNumber1);
y = linspace(-0.3,-0.001,sampledNumber2);

[X,Y] = meshgrid(x,y)
F = X;
% for phi = 0.05:0.01:0.2
xStack = nan(2,sampledNumber2,sampledNumber1);
fvalStack = nan(1,sampledNumber2,sampledNumber1);
tic

for k = 66:2:74

parfor i = 1:sampledNumber1
    xStackBuf = nan(2,sampledNumber2);
    fvalStackBuf = nan(1,sampledNumber2);
    for j = 1:sampledNumber2
        
        
    parms={};
    parms.g = 0.1;
    parms.beta = 72/180*pi;   
    parms.k = X(j,i);

    parms.mf = 0.2;
    parms.rc = 0.2;

    delta0 =  -0.005;
    parms.delta0 = Y(j,i);
    phi0 =  pi/2;
    phid0 = 0;
    x0 = [phi0;phid0];

parms.mode = 'fixedPointOpt';
[x, fval, exitflag, output] = fminunc(@(x)oneStepSimulationSLIPP(x, parms), x0, optionsFminunc);

if exitflag>0 && fval<5e-3 && abs(x(1))<pi && abs(x(2))<20
    
    parms.mode = 'simulationCheck';
    ret = oneStepSimulationSLIPP(x, parms);
    if (ret.te2/ret.te)<2
    
    
    F(j,i) = fval;
    fprintf('suceed! %dth phi and %dth phid\n',i,j)
    xStackBuf(:,j) = x;
    fvalStackBuf(:,j) = fval;
    else
        F(j,i) = nan;    
    fprintf('failed! %dth phi and %dth phid\n',i,j)
    end
else
    F(j,i) = nan;    
    fprintf('failed! %dth phi and %dth phid\n',i,j)
end
% disp(fval)
% end
% fprintf('suceed!')
    end
  xStack(:,:,i)   = xStackBuf;
  fvalStack(:,:,i)   = fvalStackBuf;
end
toc
% %   x0         = [delta0 phi0 phid0];  % The starting point.
% %   options.cl = [ 0     0    -1 ];             % Lower bounds on constraints.
% %   options.cu = [ pi/2  pi   1 ];             % Upper bounds on constraints.
% % 
% %   % Set the IPOPT options.
% % %   options.ipopt.jac_c_constant        = 'yes';
% %   options.ipopt.hessian_approximation = 'limited-memory';
% %   options.ipopt.jacobian_approximation = 'finite-difference-values';
% % %   options.ipopt.mu_strategy           = 'adaptive';
% % %   options.ipopt.tol                   = 1e-7;
% % 
% %   % The callback functions.
% %   funcs.objective         = @cost;
% %   funcs.gradient          = @gcost;
% % %   funcs.constraints       = @(x)oneStepSimulationSLIPP(x, parms);
% % %   funcs.jacobian          = @(x) sparse(ones(1,3));
% % %   funcs.jacobianstructure = @(x) sparse(ones(1,3));
% %   % Run IPOPT.
% %   [x info] = ipopt(x0,funcs,options);